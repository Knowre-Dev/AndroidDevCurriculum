# 부동 소수점

## 📌 Intro

- 1.5F * 0.3F 를 계산하면 4.5F 나와야하는데 0.45000002F 와 같이 정확한 0.45F 가 아닌 값이 결과로 리턴된다.

``` kotlin
@Test
fun floating_point() {
  val first  = 1.5F
  val second = 0.3F

  val expected = 0.45F
  val actual   = first * second

  assertThat(actual).isEqualTo(expected)
}

// org.junit.ComparisonFailure: 
// Expected :0.45f
// Actual   :0.45000002f
```

- 소수점에 민감하지 않은 어플리케이션이라면 크게 상관없을 수 있겠지만 숫자의 정확도에 민감한 어플리케이션이라면 실수 계산 오차에 대해 미리 인지하고 이에 대응하여 앱을 개발해야 할 것이다.
- 더불어, 부동 소수점 계산 방식에 대한 이해도 있다면 더욱 좋을 것이다.
- 실수 계산이 오차가 나는 이유와 부동 소수점 계산 방식을 알아보고 안드로이드에서 이 오차를 피해갈 수 있는 방법을 알아보자.

## 📌 목표
- **실수 계산이 오차가 나는 이유를 알 수 있다.**
- **부동 소수점 계산 방식을 이해한다.**
- **안드로이드에서 실수 계산 오차를 피해 개발할 수 있다.**

## 📌 실수 계산 오차

결론부터 말하자면, ✔️10진수의 소수부를 2진수로 표현할 때 값이 끝이 나지 않고 무한히 반복되는 소수부가 발생할 수 있기 때문에 오차가 생긴다.
이를 이해하기 위해 실수를 이진수로 바꿔 표현하는 방법에 대해 알아보자(컴퓨터는 모든 것을 0 과 1 이진수로 저장하므로). 
253.3 을 예제로 들어 이진수로 변환해보자.

- 정수부를 이진수로 바꾸는 법
  - 253 을 2로 나눈 나머지를 적는다. 253/2 = 몫 126 나머지 1
  - 126 을 2로 나눈 나머지를 적는다. 126/2 = 몫 63 나머지 0
  - 63 을 2로 나눈 나머지를 적는다. 63/2 = 몫 31 나머지 1
  - 31 을 2로 나눈 나머지를 적는다. 31/2 = 몫 15 나머지 1
  - 15 을 2로 나눈 나머지를 적는다. 15/2 = 몫 7 나머지 1
  - 7 을 2로 나눈 나머지를 적는다. 7/2 = 몫 3 나머지 1
  - 3 을 2로 나눈 나머지를 적는다. 3/2 = 몫 1 나머지 1
  - 더이상 나눌 수 없을 때 마지막 몫 부터 나머지를 아래부터 위로 거꾸로 나열한다.
  - 11111101

- 소수부를 이진수로 바꾸는 법
  - 0.3 에 2 를 곱한다. 0.3 * 2 = 0.6 곱한 값의 정수 부분을 적고 소수 부분만 다음 단계로 넘긴다. 0
  - 0.6 에 2 를 곱한다. 0.6 * 2 = 1.2 곱한 값의 정수 부분을 적고 소수 부분만 다음 단계로 넘긴다. 1
  - 0.2 에 2 를 곱한다. 0.2 * 2 = 0.4 곱한 값의 정수 부분을 적고 소수 부분만 다음 단계로 넘긴다. 0
  - 0.4 에 2 를 곱한다. 0.4 * 2 = 0.8 곱한 값의 정수 부분을 적고 소수 부분만 다음 단계로 넘긴다. 0
  - 0.8 에 2 를 곱한다. 0.8 * 2 = 1.6 곱한 값의 정수 부분을 적고 소수 부분만 다음 단계로 넘긴다. 1
  - 0.6 에 2 를 곱한다. 0.6 * 2 = 1.2 곱한 값의 정수 부분을 적고 소수 부분만 다음 단계로 넘긴다. 1
  - 1.2 값은 위에서도 나왔으므로 0011 부분이 계속 반복되게된다. (만약 곱한 값이 1.0 이 나오면 거기서 멈춘다.)
  - 적었던 값을 위에서 아래로 나열한다.
  - 010011001100110011......

- 위를 바탕으로 실수(253.3)를 이진수로 바꾸면,
  - 253 을 이진수로 바꾸면 -> 11111101
  - 0.3 을 이진수로 바꾸면 -> 01001100110011....
  - 253.3 = 11111101.01001100110011....
    - 결과적으로 0.3 을 이진수로 바꾸면 0011 이 계속 **무한으로 반복되게 된다.**
    - 때문에 253.3 을 이진수로 바꿔 저장하려면 계속 무한으로 반복되는 소수부를 특정 부분에서 버림해야한다. (무한한 데이터를 저장할 수 없으므로)
    - 이 때문에 실수를 이진수로 변경했을 때 무한한 값을 가지게 될 경우 실수를 저장/계산할 때 오차가 생기게 된다.

## 📌 Float 구조

### 1. 고정 소수점

![고정소수점](/Prerequisites/ComputerScience/FloatingPoint/Images/fixed_point_structure.png)

- 표현 방식
  - 총 32 비트 일 때,
  - 맨 앞 한 비트는 부호에 사용되며
  - 이어서 15비트는 정수 표현에 사용되고
  - 뒤 이어서 16비트는 소수부에 사용된다.

- 예)
  - 235.3 (11111101.01001100110011....)
    - 양수이므로 부호비트에는 0 저장
    - 정수 부분을 정수 표현 비트에 저장 000000011111101
    - 소수 부분을 소수 표현 비트에 저장(저장 가능한 16 비트까지만) 010011001100110
    - 0000000011111101010011001100110

- 고정 소수점의 문제점
  - 정수 표현부가 15비트이기 때문에 -2의 15승 부터 2의 15승 즉, -32768 ~ 32768 까지의 수만 저장 가능하게 된다.
  - 3만 5천도 저장을 못하게 됨.
  - 내 텅장에도 3만 5천원은 있음...

### 2. 부동 소수점

![부동소수점](/Prerequisites/ComputerScience/FloatingPoint/Images/floating_point_structure.png)

위처럼 고정 소수점은 그 표현범위가 매우 작다. 때문에 표현 범위를 넓힐 수 있는 방식에 대한 고민으로 부동 소수점이 나왔고 이의 표준이 [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)(전기 전자 기술자 협회 부동 소수점 표현 방식 표존)이다.
이에 대해 알아보자.

- 표현방식
  - 총 32 비트 일 때,
  - 맨 앞 한 비트는 부호에 사용되며
  - 이어서 8 비트는 지수부에 표현되며
  - 뒤 이어서 23 비트는 가수부에 사용된다.

- 예)
- 235.3 (11111101.01001100110011....)
  - 위 11111101.01001100110011.... 을 지수와 가수가 있는 표현식으로 정규화한다.
  - 정규화는 소수점 앞 부분에 1만 남도록 소수점을 옮기고 2의 지수승을 곱해 표현하는 방식을 말한다.
  - 1.1111101001100110011..*2^7 (이진수의 소수점을 앞으로 7칸 옮겼으므로 2의 7승을 곱한다.)
    - 여기서 지수는 7 가수는 소수점 아래인 **1111101001100110011..** 이다.
    - 지수 7 을 저장할 때는 지수를 저장하는 8비트에 바로 이진수로 변환해 저장하지 않고 bias(32비트일 때는 127)를 더해 저장한다.
    - 때문에, 127 + 7 = 134 를 이진수로 변환해 지수 파트에 저장한다.
      - bias 를 적용하는 이유는 정규화 과정에서 소수점이 앞으로만 갈 수 있는게 아니라 뒤로도 갈 수 있기 때문에 minus 를 표현하기 위함이다. ex(0.5) (이는 아래에서 더 다뤄보자)
      - 소수점이 뒤로 7칸 갈 때는 2의 -7승으로 표현하고 이를 이진수로 표현할 때는 127에서 -7을 더하면 120이 되고 이 값을 이진수로 변환해 저장한다.
    - **지수 134는 이진수로 10000110**
  - 그러므로 부호비트는 양수이므로 0
  - 지수 비트는 10000110
  - 가수 비트는 11111110100110011001100
  - 0 10000110 11111110100110011001100 
- 0.5 를 부동소수점으로 표현해보자 (bias 관련)
  - 0.5 를 이진수로 표현하면 
  - 0.1
  - 이를 정규화(소수점 앞부분에 1만 남도록 함)하려면 소수점을 뒤로 한칸 옮겨야함
  - 1.0*2^-1 
  - 지수승 -1 을 표현하기 위해 127 이란 bias 를 두고 127-1 = 126 을 -1 로 인식하도록 함

### 3. 안드로이드에서 실수 계산 오차를 피하자

- BigDecimal 을 사용한다.
  - 아래와 같이 BigDecimal 클래스를 이용해서 정확한 값을 계산한다.
  - 하지만 BigDecimal 은 클래스고 인스턴스 생성에 오버헤드가 걸린다.
  - 많지 않은 float 의 계산에서는 BigDecimal 의 사용이 유의미해보인다.
  - 하지만, 무수히 많은 float 의 계산 예를들어 drawing 좌표(수천, 수만 개)와 같은 것을 계산할 때는 그만큼 클래스를 만들어야하므로 성능에 무리가 갈 수 있음을 인지하자

``` kotlin
@Test
fun floating_point() {
  val first  = BigDecimal(1.5F.toString()) /** 스트링을 바꾸지 않으면 여전히 오차가 발생한다. */
  val second = 0.3F.toBigDecimal() /** 이렇게 써도 무방 */

  val expected = 0.45F
  val actual   = (first * second).toFloat() /** 코틀린에 연산자 오버로드되어 있음 */

  assertThat(actual).isEqualTo(expected)
}

//Test passed: 1 of 1 test
```

> 이미지 출처 : 
> - http://tcpschool.com/cpp/cpp_datatype_floatingPointNumber
